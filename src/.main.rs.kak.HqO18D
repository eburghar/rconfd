mod args;
mod conf;
mod errors;

// use jrsonnet_evaluator::{EvaluationState, ManifestFormat};
use std::{
	fs::{self, File},
	path::{Path, PathBuf},
};

use crate::{args::Args, conf::Conf, errors::Error};

// let state = EvaluationState::default();
// state.set_manifest_format(ManifestFormat::ToString);
// let val = state.evaluate_file_raw(&PathBuf::from(file)).map_err(|e| Error::from(e))?;
// let _val = state.with_tla(val)?;

fn is_conffile(path: &Path) -> bool {
	path.is_file()
		&& if let Some(ext) = path.extension() {
			ext == ".json"
		} else {
			false
		}
}

fn parse_config(file: &PathBuf) -> Result<Conf, Error> {
	let reader = File::open(file).unwrap();
	serde_json::from_reader::<File, Conf>(reader)?
}

/// read and parse configfile
fn config_files(dir: &String) -> Result<Vec<Conf>, Error> {
	fs::read_dir(dir)?
		.map(|r| r.map(|d| d.path()))
	println!("config files: {:?}", &entries);
		.filter(|r| r.is_ok() && is_conffile(r.as_deref().unwrap()))
		.map(|p| parse_config(&p))
		.collect()
}

fn main() -> Result<(), Error> {
	let args: Args = argh::from_env();
	let entries = config_files(&args.dir)?;
	println!("config files: {:?}", &entries);
	for entry in entries {
		if let Some(path) = entry.to_str() {
			println!("{}", path)
		}
	}
	Ok(())
}
